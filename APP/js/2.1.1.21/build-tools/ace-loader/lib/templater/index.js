const validator=require("./validator"),Parser=require("../parse/parser/index"),path=require("path");let compileResult;const EVENT_START_REGEXP=/^(on:|on|@|grab:)/,REGEXP_TEXT=/^#/;function parse(e,t,l){const a=path.parse(l);let o=a.dir.replace(process.env.aceModuleRoot||process.cwd(),"")+"/"+a.base.replace(a.ext,"");o=replaceAll(path.sep,"/",o).replace("/","");compileResult={jsonTemplate:{},deps:[],log:[]};const r=hmlParse(e,{sourceCodeLocationInfo:!0});if(checkNullNode(r,t)||checkRootNode(r,t,o))return;const i=r.childNodes.filter(function(e){return-1===e.nodeName.indexOf("#")});let n=0;i.forEach((e,t)=>{"element"!==e.tagName&&(n=t)}),generate(i[n],l,void 0,o),t(null,compileResult)}function hmlParse(e,t){return new Parser({sourceCodeLocationInfo:!0,validator:validator,compileResult:compileResult}).parseFragment(e,t)}function checkNullNode(e,t){let l=!1;return 0===e.childNodes.length&&(compileResult.log.push({reason:"ERROR: parsing hml file failed"}),t(null,compileResult),l=!0),l}function checkRootNode(e,t,l){let a=!1;let o=0;return e.childNodes.filter(function(e){return-1===e.nodeName.indexOf("#")}).forEach(e=>{if("element"!==e.nodeName)o++;else if(e.attrs&&e.attrs.length)for(let t=0;t<e.attrs.length;t++){const a=e.attrs[t];if("name"===a.name){validator.elementNames[l]=validator.elementNames[l]||[],validator.elementNames[l].push(a.value);break}}}),1!==o&&(o||compileResult.log.push({reason:"ERROR: need a legal root node",line:1,column:1}),o>1&&compileResult.log.push({reason:"ERROR: there can only be one root node",line:1,column:1}),t(null,compileResult),a=!0),a}function generate(e,t,l,a){validator.validateTagName(e,compileResult,a),e.attrs&&0!==e.attrs.length&&checkNodeAttrs(e,t,l,a),e.childNodes&&0!==e.childNodes.length&&checkNodeChildren(e,t,a)}function checkNodeAttrs(e,t,l,a){const o=e.attrs,r={line:e.sourceCodeLocation.startLine,col:e.sourceCodeLocation.endLine};o.forEach((i,n)=>{const s=i.name,c=i.value;switch(s){case"style":validator.validateStyle(c,compileResult,r,a);break;case"class":validator.validateClass(c,compileResult,r,a);break;case"id":validator.validateId(c,compileResult,r,a);break;case"for":validator.validateFor(c,compileResult,r,a);break;case"if":validator.validateIf(c,compileResult,!1,r,a);break;case"elif":validator.validateAttrElif(l,c,o,n,compileResult,r,a);break;case"else":validator.validateAttrElse(l,compileResult,r,a);break;case"append":validator.validateAppend(c,compileResult,r,a);break;default:EVENT_START_REGEXP.test(s)?validator.validateEvent(s,c,compileResult,r,a):validator.validateAttr(t,s,c,compileResult,e.tagName,r,a)}})}function replaceAll(e,t,l){return e=e.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&"),l.replace(new RegExp(e,"g"),t)}function checkNodeChildren(e,t,l){const a=e.childNodes.filter(e=>"#text"===e.nodeName&&e.value.trim()||!REGEXP_TEXT.test(e.nodeName)),o=compileResult.jsonTemplate;for(let r=0;r<a.length;r++){const i=a[r];let n;if(r>0&&(n=a[r-1]),REGEXP_TEXT.test(i.nodeName)){const a={line:i.sourceCodeLocation.startLine,col:i.sourceCodeLocation.endLine};if("option"===e.nodeName){validator.validateAttr(t,"content",i.value,compileResult,i.tagName,a,l);continue}validator.validateAttr(t,"value",i.value,compileResult,i.tagName,a,l)}else compileResult.jsonTemplate={},o.children=o.children||[],o.children.push(compileResult.jsonTemplate),generate(i,t,n,l)}compileResult.jsonTemplate=o}module.exports={parse:parse};